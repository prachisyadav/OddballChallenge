})
#rename the elements in dfs_delta_march and dfs_delta_feb to be the same. This is because when we check delta df for the name, it should be the same as the initial df.
names(dfs_latest_delete_feb) <- c("agents", "contact_centers", "interactions", "service_categories")
names(dfs_delta_march) <- c("agents", "contact_centers","interactions", "service_categories")
# ADD FUNCTION EXECUTED
# Map by name using names(dfs_initial)
dfs_latest_add_march <- lapply(names(dfs_latest_delete_feb), function(current_df) {
init_df <- dfs_latest_delete_feb[[current_df]]
# Check if there is a delta DF for this name
if (current_df %in% names(dfs_delta_march)) {
delta_df <- dfs_delta_march[[current_df]]
delta_df$action <- as.character(delta_df$action)
#remove white space from delta df's actions
delta_df$action <- trimws(as.character(delta_df$action))
#check for when action column is equal to add and filter by that
df_add <- delta_df[delta_df$action == "add", , drop = FALSE]
#for instances when the action column of a data frame is "add" and those records have been added to        df_add, append init_df with df_add using rbind.
plyr::rbind.fill(init_df, df_add)
#if the names in dfs_delta_feb dont match names_dfs_initial, then return the original df
} else {
init_df
}
})
#rename the updated dfs back to the initial names
names(dfs_latest_add_march) <- names(dfs_latest_delete_feb)
list2env(dfs_latest_add_march, envir = .GlobalEnv)
# UPDATE FUNCTION EXECUTED
# because rows_update updates records based on a unique identifier like agents_id,etc. we need to identify those primary keys
primary_keys <- c(agents='agent_id', contact_centers ='contact_center_id',interactions='interaction_id', service_categories='category_id')
#now we apply a similar process as the add function to see if the current data frame in the loop appears in dfs_delta_feb. If so, we filter the action by "update".
dfs_latest_update_march <- lapply(names(dfs_latest_add_march), function(current_df) {
init_df <- dfs_latest_add_march[[current_df]]
if (current_df %in% names(dfs_delta_march)) {
delta_df <- dfs_delta_march[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
df_update <- delta_df[delta_df$action == "update", , drop = FALSE]
#now that we've filtered by action equaling "update", if the number of rows in df_update is greater than 1, we update init df using rows_update function in dplyr, using the unique identifier key_col which is defined as the primary keys we stated above
if (nrow(df_update) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_update(init_df, df_update, by = key_col)
}
}
init_df
})
#restore the names of latest update to the ones from latest add
names(dfs_latest_update_march) <- names(dfs_latest_add_march)
list2env(dfs_latest_update_march, envir = .GlobalEnv)
# DELETE FUNCTION EXECUTED
dfs_latest_delete_march <- lapply(names(dfs_latest_update_march), function(current_df) {
init_df <- dfs_latest_update_march[[current_df]]
# Check if there is a delta DF for this table
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_march[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
# Filter "delete" actions
df_delete <- delta_df[delta_df$action == "delete", , drop = FALSE]
# If there are rows to delete, apply rows_delete by the primary key
if (nrow(df_delete) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_delete(init_df, df_delete, by = key_col)
}
}
init_df
})
names(dfs_latest_delete_march) <- names(dfs_latest_update_march)
list2env(dfs_latest_delete_march, envir = .GlobalEnv)
View(contact_centers)
View(contact_centers_delta_202503)
View(interactions)
View(interactions_delta_202502)
View(interactions_delta_202503)
#INGEST INITIAL DATA
#identify subdirectory
subdir<-"Initial"
initial_files <- list.files(
path = file.path(getwd(),subdir),
full.names = TRUE)
dfs_initial <- lapply(initial_files, read.csv)
names(dfs_initial) <- tools::file_path_sans_ext(basename(initial_files))
list2env(dfs_initial, envir = .GlobalEnv)
#rm(dfs_initial)
#PROCESS INITIAL DATA
#trim white spaces from column names
#apply a function to all data frames in the initial data list which trims all column names for white spaces from each data frame
dfs_initial <- lapply(dfs_initial, function(df) {
colnames(df) <- trimws(colnames(df))
df
})
#Set Nulls to Character type and 'Unknown'
#apply a function to all data frames in initial data list which replaces NULLs with character type and 'Unknown'
# dfs_initial <- lapply(dfs_initial, function(df){
#   df[] <- lapply(df, function(col) {
#     #replace factor or character columns with empty strings as Unknown
#     if (is.factor(col) || is.character(col)) {
#       col <- as.character(col)
#       col[col == "" | is.na(col)] <- "Unknown"
#     }
#   #only process as character type if a null exists in the column
#     else if(any(is.na(col))) {
#       col <- as.character(col)
#       col[is.na(col)] <- "Unknown"
#     }
#     col
#   })
#   df
# })
#INGEST FEBRUARY DELTA DATA
#identify subdirectory
subdir<-"Delta"
#get working dir, and list files based on wd and subdir, with regex pattern to include 'delta' for feb
delta_files_feb <- list.files(
path = file.path(getwd(),subdir),
pattern = ".*_delta_202502\\.csv$",
full.names = TRUE)
#name the data frames their original file names, and have each element df of the list dfs become a standalone data frame
dfs_delta_feb <- lapply(delta_files_feb, read.csv)
names(dfs_delta_feb) <- tools::file_path_sans_ext(basename(delta_files_feb))
list2env(dfs_delta_feb, envir = .GlobalEnv)
#rm(dfs_delta_feb)
#PROCESS FEBRUARY DELTA DATA
#CLEAN UP DATA
#trim white spaces from column names
#apply a function to all data frames in the initial data list which trims all column names for white spaces from each data frame
dfs_delta_feb <- lapply(dfs_delta_feb, function(df) {
colnames(df) <- trimws(colnames(df))
df
})
#rename the elements in dfs_initial and dfs_delta_feb to be the same. This is because when we check delta df for the name, it should be the same as the initial df.
names(dfs_initial) <- c("agents", "contact_centers", "interactions", "service_categories")
names(dfs_delta_feb) <- c("agents", "interactions", "service_categories")
# ADD FUNCTION EXECUTED
# Map by name using names(dfs_initial)
dfs_latest_add_feb <- lapply(names(dfs_initial), function(current_df) {
init_df <- dfs_initial[[current_df]]
# Check if there is a delta DF for this name
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- as.character(delta_df$action)
#remove white space from delta df's actions
delta_df$action <- trimws(as.character(delta_df$action))
#check for when action column is equal to add and filter by that
df_add <- delta_df[delta_df$action == "add", , drop = FALSE]
#for instances when the action column of a data frame is "add" and those records have been added to        df_add, append init_df with df_add using rbind.
plyr::rbind.fill(init_df, df_add)
#if the names in dfs_delta_feb dont match names_dfs_initial, then return the original df
} else {
init_df
}
})
#rename the updated dfs back to the initial names
names(dfs_latest_add_feb) <- names(dfs_initial)
list2env(dfs_latest_add_feb, envir = .GlobalEnv)
# UPDATE FUNCTION EXECUTED
# because rows_update updates records based on a unique identifier like agents_id,etc. we need to identify those primary keys
primary_keys <- c(agents='agent_id', contact_centers ='contact_center_id',interactions='interaction_id', service_categories='category_id')
#now we apply a similar process as the add function to see if the current data frame in the loop appears in dfs_delta_feb. If so, we filter the action by "update".
dfs_latest_update_feb <- lapply(names(dfs_latest_add_feb), function(current_df) {
init_df <- dfs_latest_add_feb[[current_df]]
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
df_update <- delta_df[delta_df$action == "update", , drop = FALSE]
#now that we've filtered by action equaling "update", if the number of rows in df_update is greater than 1, we update init df using rows_update function in dplyr, using the unique identifier key_col which is defined as the primary keys we stated above
if (nrow(df_update) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_update(init_df, df_update, by = key_col)
}
}
init_df
})
#restore the names of latest update to the ones from latest add
names(dfs_latest_update_feb) <- names(dfs_latest_add_feb)
list2env(dfs_latest_update_feb, envir = .GlobalEnv)
# DELETE FUNCTION EXECUTED
dfs_latest_delete_feb <- lapply(names(dfs_latest_update_feb), function(current_df) {
init_df <- dfs_latest_update_feb[[current_df]]
# Check if there is a delta DF for this table
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
# Filter "delete" actions
df_delete <- delta_df[delta_df$action == "delete", , drop = FALSE]
# If there are rows to delete, apply rows_delete by the primary key
if (nrow(df_delete) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_delete(init_df, df_delete, by = key_col)
}
}
init_df
})
names(dfs_latest_delete_feb) <- names(dfs_latest_update_feb)
list2env(dfs_latest_delete_feb, envir = .GlobalEnv)
#INGEST MARCH DELTA DATA
#identify sub directory
subdir<-"Delta"
#get working dir, and list files based on wd and subdir, with regex pattern to include 'delta' for march
delta_files_march <- list.files(
path = file.path(getwd(),subdir),
pattern = ".*_delta_202503\\.csv$",
full.names = TRUE)
#name the data frames their original file names, and have each element df of the list dfs become a standalone data frame
dfs_delta_march <- lapply(delta_files_march, read.csv)
names(dfs_delta_march) <- tools::file_path_sans_ext(basename(delta_files_march))
list2env(dfs_delta_march, envir = .GlobalEnv)
#rm(dfs_delta_march)
#PROCESS MARCH DELTA DATA
#CLEAN UP DATA
#trim white spaces from column names
#apply a function to all data frames in the initial data list which trims all column names for white spaces from each data frame
dfs_delta_march <- lapply(dfs_delta_march, function(df) {
colnames(df) <- trimws(colnames(df))
df
})
#rename the elements in dfs_delta_march and dfs_delta_feb to be the same. This is because when we check delta df for the name, it should be the same as the initial df.
names(dfs_latest_delete_feb) <- c("agents", "contact_centers", "interactions", "service_categories")
names(dfs_delta_march) <- c("agents", "contact_centers","interactions", "service_categories")
# ADD FUNCTION EXECUTED
# Map by name using names(dfs_initial)
dfs_latest_add_march <- lapply(names(dfs_latest_delete_feb), function(current_df) {
init_df <- dfs_latest_delete_feb[[current_df]]
# Check if there is a delta DF for this name
if (current_df %in% names(dfs_delta_march)) {
delta_df <- dfs_delta_march[[current_df]]
delta_df$action <- as.character(delta_df$action)
#remove white space from delta df's actions
delta_df$action <- trimws(as.character(delta_df$action))
#check for when action column is equal to add and filter by that
df_add <- delta_df[delta_df$action == "add", , drop = FALSE]
#for instances when the action column of a data frame is "add" and those records have been added to        df_add, append init_df with df_add using rbind.
plyr::rbind.fill(init_df, df_add)
#if the names in dfs_delta_feb dont match names_dfs_initial, then return the original df
} else {
init_df
}
})
#rename the updated dfs back to the initial names
names(dfs_latest_add_march) <- names(dfs_latest_delete_feb)
list2env(dfs_latest_add_march, envir = .GlobalEnv)
# UPDATE FUNCTION EXECUTED
# because rows_update updates records based on a unique identifier like agents_id,etc. we need to identify those primary keys
primary_keys <- c(agents='agent_id', contact_centers ='contact_center_id',interactions='interaction_id', service_categories='category_id')
#now we apply a similar process as the add function to see if the current data frame in the loop appears in dfs_delta_feb. If so, we filter the action by "update".
dfs_latest_update_march <- lapply(names(dfs_latest_add_march), function(current_df) {
init_df <- dfs_latest_add_march[[current_df]]
if (current_df %in% names(dfs_delta_march)) {
delta_df <- dfs_delta_march[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
df_update <- delta_df[delta_df$action == "update", , drop = FALSE]
#now that we've filtered by action equaling "update", if the number of rows in df_update is greater than 1, we update init df using rows_update function in dplyr, using the unique identifier key_col which is defined as the primary keys we stated above
if (nrow(df_update) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_update(init_df, df_update, by = key_col)
}
}
init_df
})
#restore the names of latest update to the ones from latest add
names(dfs_latest_update_march) <- names(dfs_latest_add_march)
list2env(dfs_latest_update_march, envir = .GlobalEnv)
# DELETE FUNCTION EXECUTED
dfs_latest_delete_march <- lapply(names(dfs_latest_update_march), function(current_df) {
init_df <- dfs_latest_update_march[[current_df]]
# Check if there is a delta DF for this table
if (current_df %in% names(dfs_delta_march)) {
delta_df <- dfs_delta_march[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
# Filter "delete" actions
df_delete <- delta_df[delta_df$action == "delete", , drop = FALSE]
# If there are rows to delete, apply rows_delete by the primary key
if (nrow(df_delete) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_delete(init_df, df_delete, by = key_col)
}
}
init_df
})
names(dfs_latest_delete_march) <- names(dfs_latest_update_march)
#always exporting to my global environment each time - so data frames agents, interactions, contact_centers, and service_categories stay up to date
list2env(dfs_latest_delete_march, envir = .GlobalEnv)
#now that we have finished the transformations, we can set the dfs_final as dfs_latest_delete_march
dfs_final <- dfs_latest_delete_march
list2env(dfs_final, envir = .GlobalEnv)
num_interactions <- count(dfs_final$interactions)
num_interactions <- sum(dfs_final$interactions)
num_interactions <- nrow(dfs_final$interactions)
call_min <- SUM(dfs_final$ineractions$call_duration_minutes)
call_min <- sum(dfs_final$ineractions$call_duration_minutes)
typeof(dfs_final$interactions$call_duration_minutes)
call_min <- sum(dfs_final$ineractions$call_duration_minutes)
call_min <- sum(dfs_final$interactions$call_duration_minutes)
#remove action column from final dataframes
lapply(dfs_final, function(x) {
x["action"] <- NULL;
x })
View(service_categories_delta_202503)
View(agents)
df_master<- merge(x = dfs_final$interactions, y = dfs_final$agents, by = "agent_id", all.x = TRUE)
View(df_master)
#make a master data frame by left joining the data frames using merge function
df_master <- merge(
x = dfs_final$interactions,
y = dfs_final$agents,
by = "agent_id",
all.x = TRUE,
sort = FALSE  # keeps original order
)
#making a master data frame using left join
df_master <- dfs_final$interactions %>%
left_join(
dfs_final$agents %>% distinct(agent_id, .keep_all = TRUE),
by = "agent_id"
)
#remove action column from final dataframes
lapply(dfs_final, function(x) {
x["action"] <- NULL;
x })
---
title: "R Notebook"
#INGEST INITIAL DATA
#identify subdirectory
subdir<-"Initial"
initial_files <- list.files(
path = file.path(getwd(),subdir),
full.names = TRUE)
dfs_initial <- lapply(initial_files, read.csv)
names(dfs_initial) <- tools::file_path_sans_ext(basename(initial_files))
list2env(dfs_initial, envir = .GlobalEnv)
#rm(dfs_initial)
#PROCESS INITIAL DATA
#trim white spaces from column names
#apply a function to all data frames in the initial data list which trims all column names for white spaces from each data frame
dfs_initial <- lapply(dfs_initial, function(df) {
colnames(df) <- trimws(colnames(df))
df
})
#Set Nulls to Character type and 'Unknown'
#apply a function to all data frames in initial data list which replaces NULLs with character type and 'Unknown'
# dfs_initial <- lapply(dfs_initial, function(df){
#   df[] <- lapply(df, function(col) {
#     #replace factor or character columns with empty strings as Unknown
#     if (is.factor(col) || is.character(col)) {
#       col <- as.character(col)
#       col[col == "" | is.na(col)] <- "Unknown"
#     }
#   #only process as character type if a null exists in the column
#     else if(any(is.na(col))) {
#       col <- as.character(col)
#       col[is.na(col)] <- "Unknown"
#     }
#     col
#   })
#   df
# })
#INGEST FEBRUARY DELTA DATA
#identify subdirectory
subdir<-"Delta"
#get working dir, and list files based on wd and subdir, with regex pattern to include 'delta' for feb
delta_files_feb <- list.files(
path = file.path(getwd(),subdir),
pattern = ".*_delta_202502\\.csv$",
full.names = TRUE)
#name the data frames their original file names, and have each element df of the list dfs become a standalone data frame
dfs_delta_feb <- lapply(delta_files_feb, read.csv)
names(dfs_delta_feb) <- tools::file_path_sans_ext(basename(delta_files_feb))
list2env(dfs_delta_feb, envir = .GlobalEnv)
#rm(dfs_delta_feb)
#PROCESS FEBRUARY DELTA DATA
#CLEAN UP DATA
#trim white spaces from column names
#apply a function to all data frames in the initial data list which trims all column names for white spaces from each data frame
dfs_delta_feb <- lapply(dfs_delta_feb, function(df) {
colnames(df) <- trimws(colnames(df))
df
})
#rename the elements in dfs_initial and dfs_delta_feb to be the same. This is because when we check delta df for the name, it should be the same as the initial df.
names(dfs_initial) <- c("agents", "contact_centers", "interactions", "service_categories")
names(dfs_delta_feb) <- c("agents", "interactions", "service_categories")
# ADD FUNCTION EXECUTED
# Map by name using names(dfs_initial)
dfs_latest_add_feb <- lapply(names(dfs_initial), function(current_df) {
init_df <- dfs_initial[[current_df]]
# Check if there is a delta DF for this name
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- as.character(delta_df$action)
#remove white space from delta df's actions
delta_df$action <- trimws(as.character(delta_df$action))
#check for when action column is equal to add and filter by that
df_add <- delta_df[delta_df$action == "add", , drop = FALSE]
#for instances when the action column of a data frame is "add" and those records have been added to        df_add, append init_df with df_add using rbind.
plyr::rbind.fill(init_df, df_add)
#if the names in dfs_delta_feb dont match names_dfs_initial, then return the original df
} else {
init_df
}
})
#rename the updated dfs back to the initial names
names(dfs_latest_add_feb) <- names(dfs_initial)
list2env(dfs_latest_add_feb, envir = .GlobalEnv)
# UPDATE FUNCTION EXECUTED
# because rows_update updates records based on a unique identifier like agents_id,etc. we need to identify those primary keys
primary_keys <- c(agents='agent_id', contact_centers ='contact_center_id',interactions='interaction_id', service_categories='category_id')
#now we apply a similar process as the add function to see if the current data frame in the loop appears in dfs_delta_feb. If so, we filter the action by "update".
dfs_latest_update_feb <- lapply(names(dfs_latest_add_feb), function(current_df) {
init_df <- dfs_latest_add_feb[[current_df]]
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
df_update <- delta_df[delta_df$action == "update", , drop = FALSE]
#now that we've filtered by action equaling "update", if the number of rows in df_update is greater than 1, we update init df using rows_update function in dplyr, using the unique identifier key_col which is defined as the primary keys we stated above
if (nrow(df_update) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_update(init_df, df_update, by = key_col)
}
}
init_df
})
#restore the names of latest update to the ones from latest add
names(dfs_latest_update_feb) <- names(dfs_latest_add_feb)
list2env(dfs_latest_update_feb, envir = .GlobalEnv)
# DELETE FUNCTION EXECUTED
dfs_latest_delete_feb <- lapply(names(dfs_latest_update_feb), function(current_df) {
init_df <- dfs_latest_update_feb[[current_df]]
# Check if there is a delta DF for this table
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
# Filter "delete" actions
df_delete <- delta_df[delta_df$action == "delete", , drop = FALSE]
# If there are rows to delete, apply rows_delete by the primary key
if (nrow(df_delete) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_delete(init_df, df_delete, by = key_col)
}
}
init_df
})
names(dfs_latest_delete_feb) <- names(dfs_latest_update_feb)
list2env(dfs_latest_delete_feb, envir = .GlobalEnv)
#PROCESS FEBRUARY DELTA DATA
#CLEAN UP DATA
#trim white spaces from column names
#apply a function to all data frames in the initial data list which trims all column names for white spaces from each data frame
dfs_delta_feb <- lapply(dfs_delta_feb, function(df) {
colnames(df) <- trimws(colnames(df))
df
})
#rename the elements in dfs_initial and dfs_delta_feb to be the same. This is because when we check delta df for the name, it should be the same as the initial df.
names(dfs_initial) <- c("agents", "contact_centers", "interactions", "service_categories")
names(dfs_delta_feb) <- c("agents", "interactions", "service_categories")
# ADD FUNCTION EXECUTED
# Map by name using names(dfs_initial)
dfs_latest_add_feb <- lapply(names(dfs_initial), function(current_df) {
init_df <- dfs_initial[[current_df]]
# Check if there is a delta DF for this name
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- as.character(delta_df$action)
#remove white space from delta df's actions
delta_df$action <- trimws(as.character(delta_df$action))
#check for when action column is equal to add and filter by that
df_add <- delta_df[delta_df$action == "add", , drop = FALSE]
#for instances when the action column of a data frame is "add" and those records have been added to        df_add, append init_df with df_add using rbind.
plyr::rbind.fill(init_df, df_add)
#if the names in dfs_delta_feb dont match names_dfs_initial, then return the original df
} else {
init_df
}
})
#rename the updated dfs back to the initial names
names(dfs_latest_add_feb) <- names(dfs_initial)
list2env(dfs_latest_add_feb, envir = .GlobalEnv)
# UPDATE FUNCTION EXECUTED
# because rows_update updates records based on a unique identifier like agents_id,etc. we need to identify those primary keys
primary_keys <- c(agents='agent_id', contact_centers ='contact_center_id',interactions='interaction_id', service_categories='category_id')
#now we apply a similar process as the add function to see if the current data frame in the loop appears in dfs_delta_feb. If so, we filter the action by "update".
dfs_latest_update_feb <- lapply(names(dfs_latest_add_feb), function(current_df) {
init_df <- dfs_latest_add_feb[[current_df]]
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
df_update <- delta_df[delta_df$action == "update", , drop = FALSE]
#now that we've filtered by action equaling "update", if the number of rows in df_update is greater than 1, we update init df using rows_update function in dplyr, using the unique identifier key_col which is defined as the primary keys we stated above
if (nrow(df_update) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_update(init_df, df_update, by = key_col)
}
}
init_df
})
#restore the names of latest update to the ones from latest add
names(dfs_latest_update_feb) <- names(dfs_latest_add_feb)
list2env(dfs_latest_update_feb, envir = .GlobalEnv)
# DELETE FUNCTION EXECUTED
dfs_latest_delete_feb <- lapply(names(dfs_latest_update_feb), function(current_df) {
init_df <- dfs_latest_update_feb[[current_df]]
# Check if there is a delta DF for this table
if (current_df %in% names(dfs_delta_feb)) {
delta_df <- dfs_delta_feb[[current_df]]
delta_df$action <- trimws(as.character(delta_df$action))
# Filter "delete" actions
df_delete <- delta_df[delta_df$action == "delete", , drop = FALSE]
# If there are rows to delete, apply rows_delete by the primary key
if (nrow(df_delete) > 0) {
key_col <- primary_keys[[current_df]]
init_df <- dplyr::rows_delete(init_df, df_delete, by = key_col)
}
}
init_df
})
names(dfs_latest_delete_feb) <- names(dfs_latest_update_feb)
list2env(dfs_latest_delete_feb, envir = .GlobalEnv)
